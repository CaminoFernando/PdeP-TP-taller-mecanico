--------------------------------- Taller mecanico (TP)
-- Fernando Gabriel Camino
-- Legajo: 07-138102-7
-- Paradigmas de Programacion - K2051

-- Dominio
-- Todo auto tiene
-- ●	la patente, que puede tener formato viejo “RVM363” o el nuevo “AB808RD”
-- ●	el desgaste de cada una de las llantas, ej: [ 0.5, 0.1, 0, 0.2 ]
-- ●	las revoluciones por minuto a las que regula el motor, ej: 1500
-- ●	la temperatura del agua luego de 5 minutos de encendido el auto: 90
-- ●	la fecha del último arreglo

type Desgaste = Float
type Patente = String
type Fecha = (Int, Int, Int)

-- Definiciones base
anio :: Fecha -> Int
anio (_, _, year) = year

data Auto = Auto {
    patente :: Patente,
    desgasteLlantas :: [Desgaste],
    rpm :: Int,
    temperaturaAgua :: Int,
    ultimoArreglo :: Fecha
} deriving Show


--------------------------------- Punto 1 (común): Costo de reparación de un auto
-- Saber el costo de reparación de un auto
-- ●	si la patente tiene 7 dígitos, es $ 12.500
-- ●	si no, si la patente está entre las letras "DJ" y "NB", se aplica el calculoPatental
-- ○	que es $ 3.000 * la longitud para las patentes que terminen en 4
-- ○	o $ 20.000 para el resto de las patentes
-- ●	de lo contrario, se le cobra $ 15000


costoDeReparacion::Auto->Int
costoDeReparacion auto | tienePatenteNueva auto = 12500
    | patenteEntreDJyNB auto = calculoPatental auto
    | otherwise = 15000

patenteEntreDJyNB::Auto->Bool
patenteEntreDJyNB auto = patente auto >= "DJ" && patente auto <= "NB"

calculoPatental::Auto->Int
calculoPatental auto | ((=='4').(head.((drop 5).patente))) auto = ((*3000).(length.patente)) auto
    | otherwise = 20000

tienePatenteNueva::Auto->Bool
tienePatenteNueva = ((==7).(length.patente))

--------------------------------- Importante: tenés que usar composición en las funciones auxiliares
-- Recomendación: genere valores constantes en el archivo de test ya que serán útiles en pruebas posteriores.
-- Casos de prueba que debe definir
-- Condición >>>>>> Qué se espera

-- saber el costo de reparación de un auto cuya patente es “AT001LN” >>>>>> debe ser $ 12.500
auto1Punto1 = Auto  {
    patente = "AT001LN",
    desgasteLlantas = [0.5, 0.1, 0.6, 0.4],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2016)
}

-- saber el costo de reparación de una patente “DJV214” >>>>>> debe ser $ 18.000
auto2Punto1 = Auto  {
    patente = "DJV214",
    desgasteLlantas = [0.5, 0.1, 0.6, 0.4],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2016)
}

-- saber el costo de reparación de una patente “DJV215” >>>>>> debe ser $ 20.000
auto3Punto1 = Auto  {
    patente = "DJV215",
    desgasteLlantas = [0.5, 0.1, 0.6, 0.4],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2016)
}

-- saber el costo de reparación de una patente “DFH029” >>>>>> debe ser $ 15.000
auto4Punto1 = Auto  {
    patente = "DFH029",
    desgasteLlantas = [0.5, 0.1, 0.6, 0.4],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2016)
 }


--------------------------------- Punto 2
--------------------------------- ATENCIÓN: Resolver únicamente con Composición y aplicación parcial
--------------------------------- No se puede utilizar recursividad en ningún paso de este punto.

-- Parte 1) Auto peligroso (integrante a)
-- Dado un auto, saber si es peligroso. Esta condición se cumple cuando el desgaste de la primera llanta es mayor a 0.5

esPeligroso::Auto->Bool
esPeligroso = ((>0.5).(head.desgasteLlantas))

-- Casos de prueba que debe definir
-- Condición >>>>>> Qué se espera

-- Un auto con desgaste de llantas [0.5, 0.1, 0.6, 0.4]	 >>>>>> Que no sea peligroso
auto1Punto2a = Auto  {
    patente = "DFH027",
    desgasteLlantas = [0.5, 0.1, 0.6, 0.4],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2016)
 }

-- Un auto con desgaste de llantas [0.51, 0.1, 0.6, 0.4] >>>>>> Que sea peligroso
auto2Punto2a = Auto  {
    patente = "DFH039",
    desgasteLlantas = [0.51, 0.1, 0.6, 0.4],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2016)
 }

-- Parte 2) Necesita revisión (integrante b)
-- Dado un auto, saber si necesita revisión. Esta condición se cumple cuando el último arreglo fue realizado en el año 2015 ó antes.

necesitaRevision::Auto->Bool
necesitaRevision = ((<=2015).(anio.ultimoArreglo))

-- Casos de prueba que debe definir
-- Condición >>>>>> Qué se espera

-- Un auto cuyo último arreglo fue en el 2016 >>>>>> Que no necesite revisión
auto1Punto2b = Auto  {
    patente = "DFH029",
    desgasteLlantas = [0.51, 0.1, 0.6, 0.4],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2016)
 }

-- Un auto cuyo último arreglo fue en el 2015 >>>>>> Que necesite revisión
auto2Punto2b = Auto  {
    patente = "DFH029",
    desgasteLlantas = [0.51, 0.1, 0.6, 0.4],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2015)
 }

--------------------------------- Punto 3: Personal técnico encargado de las reparaciones
-- Parte 1) Integrante a
-- Necesitamos definir a las siguientes personas que realizan actividades en el taller mecánico:
-- ●	Alfa: hace que el auto regule a 2.000 vueltas, salvo que esté a menos de 2.000 vueltas, en cuyo caso lo deja como está
-- ●	Bravo: cambia todas las cubiertas, dejándolas sin desgaste
-- ●	Charly:  realiza las mismas actividades que Alfa y Bravo

data Mecanico = Mecanico  {
    nombre :: String,
    reparacion :: String} deriving Show

reparar::Auto->Mecanico->Fecha->Auto
reparar auto mecanico fecha | reparacion mecanico == "regulacion y llantas" = cambiarLlantas (regular auto fecha) fecha
    | reparacion mecanico == "regulacion" = regular auto fecha
    | reparacion mecanico == "llantas" = cambiarLlantas auto fecha
    | otherwise = auto

cambiarLlantas::Auto->Fecha->Auto
cambiarLlantas auto fecha = Auto {
    patente = patente auto,
    desgasteLlantas = [0.0, 0.0, 0.0, 0.0],
    rpm = rpm auto,
    temperaturaAgua = temperaturaAgua auto,
    ultimoArreglo = fecha
 }

regular::Auto->Fecha->Auto
regular auto fecha | rpm auto > 2000 = Auto {
    patente = patente auto,
    desgasteLlantas = desgasteLlantas auto,
    rpm = 2000,
    temperaturaAgua = temperaturaAgua auto,
    ultimoArreglo = fecha
 }
    | otherwise = Auto {
    patente = patente auto,
    desgasteLlantas = desgasteLlantas auto,
    rpm = rpm auto,
    temperaturaAgua = temperaturaAgua auto,
    ultimoArreglo = ultimoArreglo auto
 }

-- Casos de prueba a definir
-- Los debe plantear cada integrante.

mecanicoAlfa = Mecanico  {
    nombre = "Alfa",
    reparacion = "regulacion"}

mecanicoBravo = Mecanico  {
    nombre = "Bravo",
    reparacion = "llantas"}

mecanicoCharly = Mecanico  {
    nombre = "Charly",
    reparacion = "regulacion y llantas"}

-- Un auto con desgaste de llantas [0.5, 0.1, 0.6, 0.4]	y a 2300 revoluciones reparado por "Alfa" >>>>>> Que devuelva el auto regulado a 2000
-- Un auto con desgaste de llantas [0.5, 0.1, 0.6, 0.4]	y a 2300 revoluciones reparado por "Bravo" >>>>>> Que devuelva el auto con las llantas sin desgaste
-- Un auto con desgaste de llantas [0.5, 0.1, 0.6, 0.4]	y a 2300 revoluciones reparado por "Charly" >>>>>> Que devuelva el auto regulado a 2000 y con las llantas sin desgaste
auto1Punto3a = Auto  {
    patente = "DFH029",
    desgasteLlantas = [0.51, 0.1, 0.6, 0.4],
    rpm = 2300,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2015)
 }

-- Un auto con desgaste de llantas [0.5, 0.1, 0.6, 0.4]	y a 1500 revoluciones reparado por "Alfa" >>>>>> Que devuelva el auto sin modificaciones
-- Un auto con desgaste de llantas [0.5, 0.1, 0.6, 0.4]	y a 2300 revoluciones reparado por "Charly" >>>>>> Que devuelva el auto sin modificar la regulacion y con las llantas sin desgaste
auto2Punto3a = Auto  {
    patente = "DFH028",
    desgasteLlantas = [0.51, 0.1, 0.6, 0.4],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2015)
 }

-- Parte 2) Integrante b
-- Necesitamos definir a las siguientes personas que realizan actividades en el taller mecánico
-- ●	Tango: le gusta decir que hizo muchas cosas pero en realidad no hace ningún arreglo
-- ●	Zulu: revisa la temperatura del agua, la deja a 90 y hace lo mismo que Lima (ver a continuación)
-- ●	Lima:  cambia las cubiertas delanteras (las dos primeras), dejándolas sin desgaste. Las posteriores quedan igual

reparar2::Auto->Mecanico->Fecha->Auto
reparar2 auto mecanico fecha | reparacion mecanico == "temperatura y llantas delanteras" = cambiarLlantasDelanteras (repararTemperatura auto fecha) fecha
    | reparacion mecanico == "llantas delanteras" = cambiarLlantasDelanteras auto fecha
    | reparacion mecanico == "nada" = cambiarFecha auto fecha
    | otherwise = auto

cambiarFecha::Auto->Fecha->Auto
cambiarFecha auto fecha = Auto {
    patente = patente auto,
    desgasteLlantas = desgasteLlantas auto,
    rpm = rpm auto,
    temperaturaAgua = temperaturaAgua auto,
    ultimoArreglo = fecha }

cambiarLlantasDelanteras::Auto->Fecha->Auto
cambiarLlantasDelanteras auto fecha = Auto {
    patente = patente auto,
    desgasteLlantas = (cambiarDelanteras.desgasteLlantas) auto,
    rpm = rpm auto,
    temperaturaAgua = temperaturaAgua auto,
    ultimoArreglo = fecha }

cambiarDelanteras::[Float]->[Float]
cambiarDelanteras desgaste = [0.0, 0.0] ++ (drop 2 desgaste)

repararTemperatura::Auto->Fecha->Auto
repararTemperatura auto fecha = Auto {
    patente = patente auto,
    desgasteLlantas = desgasteLlantas auto,
    rpm = rpm auto,
    temperaturaAgua = 90,
    ultimoArreglo = fecha }

-- Casos de prueba a definir
-- Los debe plantear cada integrante.

mecanicoTango = Mecanico  {
    nombre = "Tango",
    reparacion = "nada"}

mecanicoZulu = Mecanico  {
    nombre = "Zulu",
    reparacion = "temperatura y llantas delanteras"}

mecanicoLima = Mecanico  {
    nombre = "Lima",
    reparacion = "llantas delanteras"}

-- Un auto con desgaste de llantas [0.5, 0.1, 0.6, 0.4]	y 120 de temperatura reparado por "Tango" >>>>>> Que devuelva el auto sin reparaciones pero con la fecha del arreglo (que en verdad no realizó)
auto1Punto3b = Auto  {
    patente = "XRH029",
    desgasteLlantas = [0.5, 0.1, 0.6, 0.4],
    rpm = 2300,
    temperaturaAgua = 120,
    ultimoArreglo = (20,06,2015)
 }

-- Un auto con desgaste de llantas [0.5, 0.1, 0.6, 0.4]	y 120 de temperatura reparado por "Zulu" >>>>>> Que devuelva el auto con los ruedas delanteras sin desgaste y la temperatura a 90
auto2Punto3b = Auto  {
    patente = "XRH030",
    desgasteLlantas = [0.5, 0.1, 0.6, 0.4],
    rpm = 2300,
    temperaturaAgua = 120,
    ultimoArreglo = (20,06,2015)
 }

-- Un auto con desgaste de llantas [0.5, 0.1, 0.6, 0.4]	y 120 de temperatura reparado por "Lima" >>>>>> Que devuelva el auto con los ruedas delanteras sin desgaste y sin modificar la temperatura
auto3Punto3b = Auto  {
    patente = "XRH031",
    desgasteLlantas = [0.5, 0.1, 0.6, 0.4],
    rpm = 2300,
    temperaturaAgua = 120,
    ultimoArreglo = (20,06,2015)
 }


--------------------------------- Punto 4: Ordenamiento TOC de autos
--------------------------------- Solamente se puede utilizar recursividad en este punto.
--------------------------------- BONUS: Evitar repetición de código.

-- (Común para ambos integrantes) 
-- Dada una serie de autos, saber si están ordenados en base al siguiente criterio:
-- ●	los autos ubicados en la posición impar de la lista deben tener una cantidad de desgaste impar
-- ●	los autos ubicados en la posición par deben tener una cantidad de desgaste par
-- ●	asumimos que el primer elemento está en la posición 1, el segundo elemento en la posición 2, etc.

-- La cantidad de desgaste es la sumatoria de desgastes de las cubiertas de los autos multiplicada por 10. Ejemplo: 0.2 + 0.5 + 0.6 + 0.1 = 1.4 * 10 = 14. Para determinar si es par o no (y evitar errores de redondeo) es conveniente utilizar la función round.

estanBienOrdenados::[Auto]->Int->Bool
estanBienOrdenados [] _ = True
estanBienOrdenados autos n | odd (obtenerPosicion (head autos) autos n) && odd (sumatoriaDesgaste (head autos)) = estanBienOrdenados (tail autos) (incrementarNumero n)
    | even (obtenerPosicion (head autos) autos n) && even (sumatoriaDesgaste (head autos)) = estanBienOrdenados (tail autos) (incrementarNumero n)
    | otherwise = False

sumatoriaDesgaste::Auto->Int
sumatoriaDesgaste = (round.((*10).(sum.desgasteLlantas)))

incrementarNumero n = n +1

obtenerPosicion::Auto->[Auto]->Int->Int
obtenerPosicion _ [] _ = 0
obtenerPosicion y (x:xs) n | patente y == patente x = n
    |otherwise = obtenerPosicion y xs (incrementarNumero n)

--PARA OBTENER LISTA DE POSICIONES (por si el auto se ingresó más de una vez, es decir está duplicado):
--obtenerPosiciones::Auto->[Auto]->Int->[Int]
--obtenerPosiciones _ [] _ = []
--obtenerPosiciones y (x:xs) n | patente y == patente x = [n] ++ (obtenerPosiciones y xs (incrementarNumero n))
-- |otherwise = obtenerPosiciones y xs (incrementarNumero n)


-- Casos de prueba a definir
-- Condición >>>>>> Qué se espera

-- Esta lista de autos: un auto con desgaste de cubiertas [0.1, 0.4, 0.2, 0], otro auto con desgaste [0.2, 0.5, 0.6, 0.1], y otro con desgaste [0.1, 0.1, 0.1, 0]  >>>>>> Está ordenado según el criterio del enunciado
autosBienOrdenados1 = [auto1Punto4, auto2Punto4, auto3Punto4]

auto1Punto4 = Auto  {
    patente = "AFH028",
    desgasteLlantas = [0.1, 0.4, 0.2, 0],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2015)
}

auto2Punto4 = Auto  {
    patente = "AFH029",
    desgasteLlantas = [0.2, 0.5, 0.6, 0.1],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2015)
}

auto3Punto4 = Auto  {
    patente = "AFH030",
    desgasteLlantas = [0.1, 0.1, 0.1, 0],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2015)
}

-- Esta lista de autos: un auto con desgaste de cubiertas [0.1, 0.4, 0.2, 0], otro auto con desgaste [0.3, 0.5, 0.6, 0.1], y otro con desgaste [0.1, 0.1, 0.1, 0]  >>>>>> No está ordenado según el criterio del enunciado
autosMalOrdenados1 = [auto1Punto4, auto4Punto4, auto3Punto4]

auto4Punto4 = Auto  {
    patente = "AFH031",
    desgasteLlantas = [0.3, 0.5, 0.6, 0.1],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2015)
}

-- Esta lista de autos: un auto con desgaste de cubiertas [0.1, 0.4, 0.2, 0]  >>>>>> Está ordenado según el criterio del enunciado
autosBienOrdenados2 = [auto1Punto4]

-- Esta lista de autos: un auto con desgaste de cubiertas [0.1, 0.4, 0.2, 0.1] >>>>>> No está ordenado según el criterio del enunciado
autosMalOrdenados2 = [auto5Punto4]

auto5Punto4 = Auto  {
    patente = "AFH032",
    desgasteLlantas = [0.1, 0.4, 0.2, 0.1],
    rpm = 1500,
    temperaturaAgua = 90,
    ultimoArreglo = (20,06,2015)
}


--------------------------------- Punto 5: Orden de reparación
-- (Común para ambos integrantes) 
-- Aplicar una orden de reparación, que tiene
-- ●	una fecha
-- ●	una lista de técnicos
-- y consiste en que cada uno de los técnicos realice las reparaciones que sabe sobre el auto, al que además hay que actualizarle la última fecha de reparación.

aplicarOrdenDeReparacion::Fecha->[Mecanico]->Auto->Auto
aplicarOrdenDeReparacion fecha [] auto = auto
aplicarOrdenDeReparacion fecha listaMecanicos auto = aplicarOrdenDeReparacion fecha (tail listaMecanicos) (reparar2 (reparar auto (head listaMecanicos) fecha) (head listaMecanicos) fecha)

-- Casos de prueba a definir
-- Deben plantearlo los integrantes.

-- Un auto con desgaste de llantas [0.1, 0.4, 0.2, 0.1], 150 de temperatura y a 3000 revoluciones reparado por "Alfa" y "Lima" >>>>>> Que devuelva el auto regulado a 2000, con los ruedas delanteras sin desgaste y sin modificar la temperatura
mecanicosAlfaYLima = [mecanicoAlfa, mecanicoLima]

auto1Punto5 = Auto  {
    patente = "ZZH032",
    desgasteLlantas = [0.1, 0.4, 0.2, 0.1],
    rpm = 3000,
    temperaturaAgua = 150,
    ultimoArreglo = (20,06,2014)
}

-- Un auto con desgaste de llantas [0.1, 0.4, 0.2, 0.1], 150 de temperatura y a 3000 revoluciones reparado por "Charly" y "Tango" >>>>>> Que devuelva el auto regulado a 2000, con todas las llantas sin desgaste y sin modificar la temperatura
mecanicosCharlyYTango = [mecanicoCharly, mecanicoTango]

-- Un auto con desgaste de llantas [0.1, 0.4, 0.2, 0.1], 150 de temperatura y a 3000 revoluciones reparado por "Bravo" y "Zulu" >>>>>> Que devuelva con todas las llantas sin desgaste y con la temperatura a 90 (sin modificar regulacion)
mecanicosBravoYZulu = [mecanicoBravo, mecanicoZulu]

-- Un auto con desgaste de llantas [0.1, 0.4, 0.2, 0.1], 150 de temperatura y a 3000 revoluciones reparado por todos los mecanicos >>>>>> Que devuelva con todas las llantas sin desgaste, la temperatura a 90 y regulado a 2000 revoluciones
mecanicosTodos = [mecanicoAlfa, mecanicoBravo, mecanicoCharly, mecanicoTango, mecanicoZulu, mecanicoLima]


--------------------------------- Punto 6
--------------------------------- Solamente se puede utilizar funciones de orden superior en este punto.

-- Parte 1) Integrante a: Técnicos que dejan el auto en condiciones
-- Dada una lista de técnicos determinar aquellos técnicos que dejarían el auto en condiciones (que no sea peligroso andar, recordar el punto 2.1 del integrante a).

quienesLoDejanEnCondiciones::[Mecanico]->Auto->Fecha->[String]
quienesLoDejanEnCondiciones [] auto fecha = []
quienesLoDejanEnCondiciones mecanicos auto fecha | esPeligroso (aplicarOrdenDeReparacion fecha mecanicos auto) = []
    | esPeligroso (aplicarOrdenDeReparacion fecha [head mecanicos] auto) = quienesLoDejanEnCondiciones (tail mecanicos) auto fecha
    | otherwise = [(nombre.head) mecanicos] ++ quienesLoDejanEnCondiciones (tail mecanicos) auto fecha

-- Parte 2) Integrante b: Costo de reparación de autos que necesitan revisión
-- Dada una lista de autos, saber cuál es el costo de reparación de los autos que necesitan revisión.

costoDeReparacionTotal::[Auto]->Int
costoDeReparacionTotal [] = 0
costoDeReparacionTotal autos | necesitaRevision (head autos) = costoDeReparacion (head autos) + costoDeReparacionTotal (tail autos)
    | otherwise = costoDeReparacionTotal (tail autos)

-- Casos de prueba a definir
-- Condición  >>>>>> Qué se espera

-- Tenemos un auto que tiene 0.6 de desgaste en la primera cubierta. Armamos la lista de técnicos con [alfa, bravo, charly, tango, zulu, lima]  >>>>>> 	Que cuatro de los técnicos dejen el auto en condiciones (serían bravo, charly, zulu y lima, pero está fuera del alcance de la cursada determinar que son ellos)
lista1MecanicosPunto6 = [mecanicoAlfa, mecanicoBravo, mecanicoCharly, mecanicoTango, mecanicoZulu, mecanicoLima]

auto1Punto6 = Auto  {
    patente = "AT001LN",
    desgasteLlantas = [0.6, 0.4, 0.2, 0.1],
    rpm = 3000,
    temperaturaAgua = 150,
    ultimoArreglo = (20,06,2015)
}

-- Tenemos un auto que tiene 0.5 de desgaste en la primera cubierta. Armamos la lista de técnicos con [alfa, bravo, charly, tango, zulu, lima]  >>>>>> Todos los técnicos dejan el auto en condiciones (la lista tiene 6 elementos), ya que el auto no es peligroso de antemano.
lista2MecanicosPunto6 = [mecanicoAlfa, mecanicoBravo, mecanicoCharly, mecanicoTango, mecanicoZulu, mecanicoLima]

auto2Punto6 = Auto  {
    patente = "DJV214",
    desgasteLlantas = [0.5, 0.4, 0.2, 0.1],
    rpm = 3000,
    temperaturaAgua = 150,
    ultimoArreglo = (20,06,2018)
}

-- Dada una lista de autos cuyas patentes son “AT001LN”, “DJV214”, “DJV215”, “DFH029”, donde “AT001LN” y “DFH029” son los que necesitan revisión >>>>>> El costo de reparación de los autos que necesitan revisión debe ser $ 27.500 ($ 12.500 de “AT001LN” + $ 15.000 de “DFH029”)
listaAutos = [auto1Punto6, auto2Punto6, auto3Punto6, auto4Punto6]

auto3Punto6 = Auto  {
    patente = "DJV215",
    desgasteLlantas = [0.5, 0.4, 0.2, 0.1],
    rpm = 3000,
    temperaturaAgua = 150,
    ultimoArreglo = (20,06,2019)
}

auto4Punto6 = Auto  {
    patente = "DFH029",
    desgasteLlantas = [0.5, 0.4, 0.2, 0.1],
    rpm = 3000,
    temperaturaAgua = 150,
    ultimoArreglo = (20,06,2013)
}

--------------------------------- Punto 7
-- Parte 1) Integrante a: Técnicos que dejan el auto en condiciones
-- En base al punto “dada una lista de técnicos determinar qué técnicos dejarían el auto en condiciones” y considerando una lista de técnicos  infinita, ¿podríamos obtener el primer técnico que deja el auto en condiciones? Muestre un ejemplo y justifique. 


-- RESPUESTA: Si, se puede obtener al primer técnico que deja el auto en condiciones ya que Haskell trabaja con evaluación perezosa (lazy evaluation), de manera que se van evaluando los argumentos a medida que los va necesitando. Ejemplo:

tecnicosInfinitos = mecanicoZulu:tecnicosInfinitos

obtenerPrimerMecanico::[Mecanico]->Auto->Fecha->[Mecanico]
obtenerPrimerMecanico [] auto fecha = []
obtenerPrimerMecanico mecanicos auto fecha | (length (quienesLoDejanEnCondiciones [head mecanicos] auto fecha)) == 1 = [head mecanicos]
    | otherwise = obtenerPrimerMecanico (tail mecanicos) auto fecha

auto1Punto7 = Auto  {
    patente = "JJ001LN",
    desgasteLlantas = [0.6, 0.4, 0.2, 0.1],
    rpm = 3000,
    temperaturaAgua = 150,
    ultimoArreglo = (20,06,2015)
}


-- Parte 2) Integrante b: Costo de reparación de autos que necesitan revisión
-- En base al punto “Dada una lista de autos, saber cuál es el costo de reparación de los autos que necesitan revisión.”,  ¿podríamos tener una lista infinita de autos? Muestre un ejemplo y justifique. 


-- RESPUESTA: No se puede utilizar una lista infinita en la función costoDeReparacionTotal ya que para mostrar el resultado primero tiene que recorrer toda la lista evaluando si cada elemento necesita una revisión, al nunca poder terminar de realizar dichas evaluaciones el compilador se quedará procesando información por tiempo indeterminado. Ejemplo:

autosInfinitos :: [Auto]
autosInfinitos = autosInfinitos' 0

autosInfinitos' :: Int -> [Auto]
autosInfinitos' n = Auto {
    patente = "AAA000",
    desgasteLlantas = [0.5, 0.1, 0.2, 0.3],
    rpm = 1500 + n,
    temperaturaAgua = 90,
    ultimoArreglo = (20, 1, 2013)
} : autosInfinitos' (n + 1)

-- *Main> costoDeReparacionTotal autosInfinitos
-- Interrupted.



-- Y si tomáramos en cuenta los tres primeros autos que necesitan revisión, ¿cómo debería cambiar la función? Por otra parte, ¿esta versión aceptaría una lista infinita de autos? Modifique la función 6.b con otro nombre y justifique sus respuestas.


-- RESPUESTA: Si, esta nueva versión aceptaría una lista infinita de autos ya que nosotros estamos acotando manualmente cuantos son los elementos que precisamos obtener, gracias a la evaluación perezosa (lazy evaluation) con la que trabaja Haskell se van evaluando los argumentos a medida que los va necesitando. Ejemplo:

disminuirNumero n = n -1

costoDeReparacionDeLosPrimeros::Int->[Auto]->Int
costoDeReparacionDeLosPrimeros n [] = 0
costoDeReparacionDeLosPrimeros n autos | n > 0 && necesitaRevision (head autos) = costoDeReparacion (head autos) + costoDeReparacionDeLosPrimeros (disminuirNumero n) (tail autos)
    | n == 0 = 0
    | otherwise = costoDeReparacionDeLosPrimeros n (tail autos)
